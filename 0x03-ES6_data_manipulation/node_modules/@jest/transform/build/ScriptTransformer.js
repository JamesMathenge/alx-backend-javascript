'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;

function _crypto() {
  const data = _interopRequireDefault(require('crypto'));

  _crypto = function _crypto() {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require('path'));

  _path = function _path() {
    return data;
  };

  return data;
}

function _vm() {
  const data = _interopRequireDefault(require('vm'));

  _vm = function _vm() {
    return data;
  };

  return data;
}

function _jestUtil() {
  const data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _gracefulFs() {
  const data = _interopRequireDefault(require('graceful-fs'));

  _gracefulFs = function _gracefulFs() {
    return data;
  };

  return data;
}

function _core() {
  const data = require('@babel/core');

  _core = function _core() {
    return data;
  };

  return data;
}

function _babelPluginIstanbul() {
  const data = _interopRequireDefault(require('babel-plugin-istanbul'));

  _babelPluginIstanbul = function _babelPluginIstanbul() {
    return data;
  };

  return data;
}

function _convertSourceMap() {
  const data = _interopRequireDefault(require('convert-source-map'));

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

function _jestHasteMap() {
  const data = _interopRequireDefault(require('jest-haste-map'));

  _jestHasteMap = function _jestHasteMap() {
    return data;
  };

  return data;
}

function _fastJsonStableStringify() {
  const data = _interopRequireDefault(require('fast-json-stable-stringify'));

  _fastJsonStableStringify = function _fastJsonStableStringify() {
    return data;
  };

  return data;
}

function _slash() {
  const data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _writeFileAtomic() {
  const data = _interopRequireDefault(require('write-file-atomic'));

  _writeFileAtomic = function _writeFileAtomic() {
    return data;
  };

  return data;
}

function _realpathNative() {
  const data = require('realpath-native');

  _realpathNative = function _realpathNative() {
    return data;
  };

  return data;
}

function _pirates() {
  const data = require('pirates');

  _pirates = function _pirates() {
    return data;
  };

  return data;
}

var _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));

var _enhanceUnexpectedTokenMessage = _interopRequireDefault(
  require('./enhanceUnexpectedTokenMessage')
);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function() {
    var self = this,
      args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }
      _next(undefined);
    });
  };
}

// Use `require` to avoid TS rootDir
const _require = require('../package.json'),
  VERSION = _require.version; // This data structure is used to avoid recalculating some data every time that
// we need to transform a file. Since ScriptTransformer is instantiated for each
// file we need to keep this object in the local scope of this module.

const projectCaches = new WeakMap(); // To reset the cache for specific changesets (rather than package version).

const CACHE_VERSION = '1';

function waitForPromiseWithCleanup(_x, _x2) {
  return _waitForPromiseWithCleanup.apply(this, arguments);
}

function _waitForPromiseWithCleanup() {
  _waitForPromiseWithCleanup = _asyncToGenerator(function*(promise, cleanup) {
    try {
      yield promise;
    } finally {
      cleanup();
    }
  });
  return _waitForPromiseWithCleanup.apply(this, arguments);
}

class ScriptTransformer {
  constructor(config) {
    _defineProperty(this, '_cache', void 0);

    _defineProperty(this, '_config', void 0);

    _defineProperty(this, '_transformCache', void 0);

    _defineProperty(this, '_transformConfigCache', void 0);

    this._config = config;
    this._transformCache = new Map();
    this._transformConfigCache = new Map();
    let projectCache = projectCaches.get(config);

    if (!projectCache) {
      projectCache = {
        configString: (0, _fastJsonStableStringify().default)(this._config),
        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),
        transformRegExp: calcTransformRegExp(this._config),
        transformedFiles: new Map()
      };
      projectCaches.set(config, projectCache);
    }

    this._cache = projectCache;
  }

  _getCacheKey(fileData, filename, instrument) {
    const configString = this._cache.configString;

    const transformer = this._getTransformer(filename);

    if (transformer && typeof transformer.getCacheKey === 'function') {
      return _crypto()
        .default.createHash('md5')
        .update(
          transformer.getCacheKey(fileData, filename, configString, {
            config: this._config,
            instrument,
            rootDir: this._config.rootDir
          })
        )
        .update(CACHE_VERSION)
        .digest('hex');
    } else {
      return _crypto()
        .default.createHash('md5')
        .update(fileData)
        .update(configString)
        .update(instrument ? 'instrument' : '')
        .update(filename)
        .update(CACHE_VERSION)
        .digest('hex');
    }
  }

  _getFileCachePath(filename, content, instrument) {
    const baseCacheDir = _jestHasteMap().default.getCacheFilePath(
      this._config.cacheDirectory,
      'jest-transform-cache-' + this._config.name,
      VERSION
    );

    const cacheKey = this._getCacheKey(content, filename, instrument); // Create sub folders based on the cacheKey to avoid creating one
    // directory with many files.

    const cacheDir = _path().default.join(
      baseCacheDir,
      cacheKey[0] + cacheKey[1]
    );

    const cacheFilenamePrefix = _path()
      .default.basename(filename, _path().default.extname(filename))
      .replace(/\W/g, '');

    const cachePath = (0, _slash().default)(
      _path().default.join(cacheDir, cacheFilenamePrefix + '_' + cacheKey)
    );
    (0, _jestUtil().createDirectory)(cacheDir);
    return cachePath;
  }

  _getTransformPath(filename) {
    const transformRegExp = this._cache.transformRegExp;

    if (!transformRegExp) {
      return undefined;
    }

    for (let i = 0; i < transformRegExp.length; i++) {
      if (transformRegExp[i][0].test(filename)) {
        const transformPath = transformRegExp[i][1];

        this._transformConfigCache.set(transformPath, transformRegExp[i][2]);

        return transformPath;
      }
    }

    return undefined;
  }

  _getTransformer(filename) {
    let transform = null;

    if (!this._config.transform || !this._config.transform.length) {
      return null;
    }

    const transformPath = this._getTransformPath(filename);

    if (transformPath) {
      const transformer = this._transformCache.get(transformPath);

      if (transformer != null) {
        return transformer;
      }

      transform = require(transformPath);

      const transformerConfig = this._transformConfigCache.get(transformPath);

      if (typeof transform.createTransformer === 'function') {
        transform = transform.createTransformer(transformerConfig);
      }

      if (typeof transform.p